/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
typedef pair<int, pii> piii;

const int maxn = 200 * 200 + 1;
int f[maxn], v1[maxn], v2[maxn], v3[maxn];

int find(int u) {
    return u == f[u] ? u : f[u] = find(f[u]);
}
void merge(int u, int v) {
    int fu = find(u);
    int fv = find(v);
    if (fu == fv) return;
    f[fu] = fv;
    v1[fv] += v1[fu];
    v2[fv] += v2[fu];
    v3[fv] += v3[fu];
}

class Solution {
   public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        int n = heightMap.size();
        int m = heightMap[0].size();
        vector<piii> V;

        auto get_idx = [&](int x, int y) {
            return x * m + y;
        };

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                V.push_back({heightMap[i][j], {i, j}});
                int idx = get_idx(i, j);
                f[idx] = idx;
                v1[idx] = 0;
                v2[idx] = 0;
                v3[idx] = 0;
            }
        }
        int empty_idx = n * m;
        f[empty_idx] = empty_idx;
        v1[empty_idx] = 0;
        v2[empty_idx] = 0;
        v3[empty_idx] = 0;

        sort(V.begin(), V.end());
        int d[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
        int sz = V.size();

        long long ans = 0;
        vector<vector<int>> vis(n, vector<int>(m, 0));
        for (int i = 0; i < sz; i++) {
            int val = V[i].first, x = V[i].second.first, y = V[i].second.second;
            vis[x][y] = 1;
            int idx1 = get_idx(x, y);
            for (int j = 0; j < 4; j++) {
                int x2 = x + d[j][0], y2 = y + d[j][1];
                if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < m) {
                    int idx2 = get_idx(x2, y2);
                    int fidx2 = find(idx2);
                    if (fidx2 != find(empty_idx)) {
                        ans -= v3[fidx2];
                        int tmp = v1[fidx2] * val - v2[fidx2];
                        v3[fidx2] = tmp;
                        ans += tmp;
                    }
                }
            }
            v1[idx1] = 1;
            v2[idx1] = val;
            for (int j = 0; j < 4; j++) {
                int x2 = x + d[j][0], y2 = y + d[j][1];
                if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < m) {
                    int idx2 = get_idx(x2, y2);
                    if (vis[x2][y2] == 1)
                        merge(idx1, idx2);
                } else {
                    merge(idx1, empty_idx);
                }
            }
        }
        return ans;
    }
};