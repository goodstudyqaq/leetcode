/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

template <class T>
auto vect(const T& v, int n) { return vector<T>(n, v); }
template <class T, class... D>
auto vect(const T& v, int n, D... m) {
    return vector<decltype(vect(v, m...))>(n, vect(v, m...));
}

template <typename T>
static constexpr T inf = numeric_limits<T>::max() / 2;
mt19937_64 mrand(random_device{}());
long long rnd(long long x) { return mrand() % x; }
int lg2(long long x) { return sizeof(long long) * 8 - 1 - __builtin_clzll(x); }


class Solution {
   public:
    bool isScramble(string s1, string s2) {
        int n = s1.size();

        string tmp_s1 = s1, tmp_s2 = s2;
        sort(tmp_s1.begin(), tmp_s1.end());
        sort(tmp_s2.begin(), tmp_s2.end());
        if (tmp_s1 != tmp_s2) return false;

        auto dp = vect(-1, n, n, n + 1);
        function<bool(int, int, int)> dfs = [&](int idx1, int idx2, int length) -> bool {
            if (dp[idx1][idx2][length] != -1) return dp[idx1][idx2][length];

            if (s1.substr(idx1, length) == s2.substr(idx2, length)) {
                return dp[idx1][idx2][length] = true;
            }

            // reverse
            int ed = idx1 + length - 1;
            for (int i = idx1; i < ed; i++) {
                int len = i - idx1 + 1;
                bool flag = (dfs(idx1, idx2 + length - len, len) & dfs(idx1 + len, idx2, length - len)) | (dfs(idx1, idx2, len) & dfs(idx1 + len, idx2 + len, length - len));
                if (flag) {
                    return dp[idx1][idx2][length] = flag;
                }
            }
            return dp[idx1][idx2][length] = false;
        };     


        return dfs(0, 0, n);

    }
};