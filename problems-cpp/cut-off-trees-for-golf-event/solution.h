/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
class Solution {
   public:
    int cutOffTree(vector<vector<int>>& forest) {
        int n = forest.size();
        int m = forest[0].size();
        int N = n * m;

        auto get_loc = [&](int idx) -> pii {
            return {idx / m, idx % m};
        };

        auto get_idx = [&](int x, int y) {
            return x * m + y;
        };
        const int inf = numeric_limits<int>::max() / 2;

        vector<int> f(N);
        iota(f.begin(), f.end(), 0);
        sort(f.begin(), f.end(), [&](int x, int y) {
            auto it1 = get_loc(x), it2 = get_loc(y);
            return forest[it1.first][it1.second] < forest[it2.first][it2.second];
        });

        int begin = 0;
        while (true) {
            int idx = f[begin];
            auto [x, y] = get_loc(idx);
            if (forest[x][y] <= 1) {
                begin++;
            } else {
                break;
            }
        }

        int dir[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
        auto work = [&](int x1, int y1, int x2, int y2) {
            queue<pii> Q;
            vector<vector<int>> d(n, vector<int>(m, inf));
            d[x1][y1] = 0;
            Q.push({x1, y1});

            while (!Q.empty()) {
                auto [x, y] = Q.front();
                Q.pop();
                if (x == x2 && y == y2) return d[x][y];
                for (int i = 0; i < 4; i++) {
                    int gox = x + dir[i][0];
                    int goy = y + dir[i][1];
                    if (gox >= 0 && gox < n && goy >= 0 && goy < m && d[gox][goy] == inf && forest[gox][goy] != 0) {
                        d[gox][goy] = d[x][y] + 1;
                        Q.push({gox, goy});
                    }
                }
            }
            return inf;
        };

        int nowx = 0, nowy = 0;
        int ans = 0;
        for (int i = begin; i < N; i++) {
            int idx = f[i];
            auto [x, y] = get_loc(idx);
            int res = work(nowx, nowy, x, y);
            if (res == inf) return -1;
            ans += res;
            nowx = x;
            nowy = y;
        }
        return ans;

    }
};