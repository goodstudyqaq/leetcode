/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

struct Poly {
    vector<int> coef;
    vector<vector<string>> names;
    Poly() {}

    Poly operator-() {
        for (int i = 0; i < coef.size(); i++) {
            coef[i] *= -1;
        }
        return *this;
    }

    Poly operator+(const Poly& b) const {
        Poly res;
        res.coef = coef;
        res.names = names;

        for (int i = 0; i < b.coef.size(); i++) {
            bool flag = false;
            for (int j = 0; j < res.coef.size(); j++) {
                if (res.names[j] == b.names[i]) {
                    flag = true;
                    res.coef[j] += b.coef[i];
                    break;
                }
            }
            if (!flag) {
                res.coef.push_back(b.coef[i]);
                res.names.push_back(b.names[i]);
            }
        }

        int now = 0;
        for (int i = 0; i < res.coef.size(); i++) {
            if (res.coef[i] != 0) {
                res.coef[now] = res.coef[i];
                res.names[now] = res.names[i];
                now++;
            }
        }
        res.coef.resize(now);
        res.names.resize(now);
        return res;
    }

    Poly operator-(const Poly& b) const {
        Poly c = b;
        return *this + (-c);
    }

    Poly operator*(const Poly& b) const {
        Poly res;
        int bsz = b.coef.size();
        int sz = coef.size();
        map<vector<string>, int> idx;
        for (int i = 0; i < sz; i++) {
            for (int j = 0; j < bsz; j++) {
                int new_coef = coef[i] * b.coef[j];
                vector<string> new_names;
                for (auto it : names[i]) new_names.push_back(it);
                for (auto it : b.names[j]) new_names.push_back(it);
                sort(new_names.begin(), new_names.end());
                if (idx.count(new_names)) {
                    int the_idx = idx[new_names];
                    res.coef[the_idx] += new_coef;
                } else {
                    res.coef.push_back(new_coef);
                    res.names.push_back(new_names);
                    idx[new_names] = res.coef.size() - 1;
                }
            }
        }
        int now = 0;
        for (int i = 0; i < res.coef.size(); i++) {
            if (res.coef[i] != 0) {
                res.coef[now] = res.coef[i];
                res.names[now] = res.names[i];
                now++;
            }
        }
        res.coef.resize(now);
        res.names.resize(now);

        return res;
    }
};

bool delim(char c) { return c == ' '; }

bool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/'; }

bool is_unary(char c) { return c == '+' || c == '-'; }

int priority(char op) {
    if (op < 0)  // unary operator
        return 3;
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return -1;
}

void process_op(stack<Poly>& st, char op) {
    if (op < 0) {
        auto l = st.top();
        st.pop();
        switch (-op) {
            case '+':
                st.push(l);
                break;
            case '-':
                st.push(-l);
                break;
        }
    } else {  // 取出栈顶元素，注意顺序
        auto r = st.top();
        st.pop();
        auto l = st.top();
        st.pop();
        switch (op) {
            case '+':
                st.push(l + r);
                break;
            case '-':
                st.push(l - r);
                break;
            case '*':
                st.push(l * r);
                break;
        }
    }
}

set<char> S{'+', '-', '*', '/'};
bool left_assoc(char op) {
    return S.count(op);
}

// string to_string(Poly a) {
//     return to_string(a.coef) + " " + to_string(a.names);
// }

Poly evaluate(string& s, unordered_map<string, int>& eva) {
    stack<Poly> st;
    stack<char> op;
    bool may_be_unary = true;
    for (int i = 0; i < (int)s.size(); i++) {
        if (delim(s[i])) continue;
        if (s[i] == '(') {
            op.push('(');  // 2. 如果遇到左括号，那么将其放在运算符栈上
            may_be_unary = true;
        } else if (s[i] == ')') {  // 3. 如果遇到右括号，执行一对括号内的所有运算符
            while (op.top() != '(') {
                process_op(st, op.top());
                op.pop();  // 不断输出栈顶元素，直至遇到左括号
            }
            op.pop();  // 左括号出栈
            may_be_unary = false;
        } else if (is_op(s[i])) {  // 4. 如果遇到其他运算符
            char cur_op = s[i];
            if (may_be_unary && is_unary(cur_op)) cur_op = -cur_op;
            while (!op.empty() &&
                   ((left_assoc(cur_op) && priority(op.top()) >= priority(cur_op)) || (!left_assoc(cur_op) && priority(op.top()) > priority(cur_op)))) {
                process_op(st, op.top());
                op.pop();  // 不断输出所有运算优先级大于等于当前运算符的运算符
            }
            op.push(cur_op);  // 新的运算符入运算符栈
            may_be_unary = true;
        } else {  // 1. 如果遇到数字，直接输出该数字
            if (s[i] >= '0' && s[i] <= '9') {
                // number
                int number = 0;
                while (i < s.size() && s[i] >= '0' && s[i] <= '9') {
                    number = number * 10 + s[i++] - '0';
                }
                i--;
                Poly now;
                now.coef.push_back(number);
                now.names.push_back({});
                st.push(now);
            } else {
                // name
                string name = "";
                while (i < s.size() && s[i] >= 'a' && s[i] <= 'z') {
                    name += s[i++];
                }
                i--;
                Poly now;
                if (eva.count(name)) {
                    now.coef.push_back(eva[name]);
                    now.names.push_back({});
                } else {
                    now.coef.push_back(1);
                    now.names.push_back({name});
                }
                st.push(now);
            }
            may_be_unary = false;
        }
    }

    while (!op.empty()) {
        process_op(st, op.top());
        op.pop();
    }
    return st.top();
}

class Solution {
   public:
    vector<string> basicCalculatorIV(string expression, vector<string>& evalvars, vector<int>& evalints) {
        debug(expression, evalvars, evalints);
        unordered_map<string, int> eva;
        for (int i = 0; i < evalvars.size(); i++) {
            eva[evalvars[i]] = evalints[i];
        }
        auto res = evaluate(expression, eva);
        // debug(res);
        debug(res.coef);
        debug(res.names);

        int now = 0;
        for (int i = 0; i < res.coef.size(); i++) {
            if (res.coef[i] != 0) {
                res.coef[now] = res.coef[i];
                res.names[now] = res.names[i];
                now++;
            }
        }
        res.coef.resize(now);
        res.names.resize(now);

        int n = res.coef.size();
        for (int i = 0; i < n; i++) {
            sort(res.names[i].begin(), res.names[i].end());
        }
        vector<int> f(n);
        iota(f.begin(), f.end(), 0);
        sort(f.begin(), f.end(), [&](int x, int y) {
            if (res.names[x].size() != res.names[y].size()) {
                return res.names[x].size() > res.names[y].size();
            }
            return res.names[x] < res.names[y];
        });
        vector<string> ans(n);

        for (int i = 0; i < n; i++) {
            int idx = f[i];
            int num = res.coef[idx];
            string snum = to_string(num);
            string it = "";

            int sz = res.names[idx].size();
            for (int j = 0; j < sz; j++) {
                it += res.names[idx][j];
                if (j != sz - 1) {
                    it += '*';
                }
            }
            if (it.size()) {
                snum += "*" + it;
            }
            ans[i] = snum;
        }
        return ans;
    }
};