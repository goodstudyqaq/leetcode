/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

template <class T>
auto vect(const T& v, int n) { return vector<T>(n, v); }
template <class T, class... D>
auto vect(const T& v, int n, D... m) {
    return vector<decltype(vect(v, m...))>(n, vect(v, m...));
}

template <typename T>
static constexpr T inf = numeric_limits<T>::max() / 2;
mt19937_64 mrand(random_device{}());
long long rnd(long long x) { return mrand() % x; }
int lg2(long long x) { return sizeof(long long) * 8 - 1 - __builtin_clzll(x); }

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

typedef pair<int, int> pii;
typedef tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

class Solution {
   public:
    int cherryPickup(vector<vector<int>>& grid) {
        int n = grid.size();

        const int inf = numeric_limits<int>::max() / 2;
        auto dp = vect(-inf, 2 * n, n, n);
        dp[0][0][0] = grid[0][0];

        for (int d = 1; d < 2 * n; d++) {
            for (int x1 = max(0, d - n + 1); x1 < min(n, d + 1); x1++) {
                int y1 = d - x1;
                for (int x2 = max(0, d - n + 1); x2 < min(n, d + 1); x2++) {
                    int y2 = d - x2;
                    if (grid[x1][y1] == -1 || grid[x2][y2] == -1) {
                        continue;
                    }

                    int f = grid[x1][y1] + grid[x2][y2];
                    if (grid[x1][y1] && x1 == x2) f--;

                    for (int i = 0; i < 2; i++) {
                        if (x1 - i < 0) break;
                        for (int j = 0; j < 2; j++) {
                            if (x2 - j < 0) break;
                            int x3 = x1 - i;
                            int y3 = d - 1 - x3;
                            int x4 = x2 - j;
                            int y4 = d - 1 - x4;
                            if (x3 >= 0 && x3 < n && y3 >= 0 && y3 < n && x4 >= 0 && x4 < n && y4 >= 0 && y4 < n && grid[x3][y3] != -1 && grid[x4][y4] != -1) {
                                dp[d][x1][x2] = max(dp[d][x1][x2], dp[d - 1][x3][x4] + f);
                            }
                        }
                    }
                    debug(d, x1, x2, dp[d][x1][x2]);
                }
            }
        }
        int ans = dp[n * 2 - 2][n - 1][n - 1];
        if (ans < 0) return 0;
        return ans;
    }
};