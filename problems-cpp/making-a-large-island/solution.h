/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

struct DSU {
    std::vector<int> f;
    std::vector<int> cnt;
    DSU(int n) : f(n), cnt(n, 1) { std::iota(f.begin(), f.end(), 0); }
    int leader(int x) {
        if (f[x] == x) {
            return x;
        }
        int y = leader(f[x]);
        f[x] = y;
        return f[x];
    }
    bool merge(int a, int b) {
        auto x = leader(a);
        auto y = leader(b);
        if (x == y) {
            return false;
        }
        f[x] = y;
        cnt[y] += cnt[x];
        return true;
    }
};

typedef pair<int, int> pii;

class Solution {
   public:
    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();

        auto get_idx = [&](int x, int y) {
            return x * m + y;
        };

        auto get_loc = [&](int idx) -> pii {
            return {idx / m, idx % m};
        };

        int d[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
        DSU dsu(n * m);

        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1) {
                    int idx = get_idx(i, j);
                    for (int k = 0; k < 4; k++) {
                        int i2 = i + d[k][0], j2 = j + d[k][1];
                        if (i2 >= 0 && i2 < n && j2 >= 0 && j2 < m && grid[i2][j2] == 1) {
                            int idx2 = get_idx(i2, j2);
                            dsu.merge(idx, idx2);
                        }
                    }
                    ans = max(ans, dsu.cnt[dsu.leader(idx)]);
                }
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 0) {
                    int tmp = 1;
                    unordered_set<int> tmpS;
                    for (int k = 0; k < 4; k++) {
                        int i2 = i + d[k][0], j2 = j + d[k][1];
                        if (i2 >= 0 && i2 < n && j2 >= 0 && j2 < m && grid[i2][j2] == 1) {
                            int idx2 = get_idx(i2, j2);
                            int fidx2 = dsu.leader(idx2);
                            if (tmpS.count(fidx2) == 0) {
                                tmp += dsu.cnt[fidx2];
                                tmpS.insert(fidx2);
                            }
                        }
                    }
                    ans = max(ans, tmp);
                }
            }
        }
        return ans;
    }
};