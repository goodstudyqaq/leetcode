/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

vector<string> split(string &s, string delimiter) {
    size_t pos_start = 0, pos_end, delim_len = delimiter.length();
    string token;
    vector<string> res;

    while ((pos_end = s.find(delimiter, pos_start)) != string::npos) {
        token = s.substr(pos_start, pos_end - pos_start);
        pos_start = pos_end + delim_len;
        res.push_back(token);
    }

    res.push_back(s.substr(pos_start));
    return res;
}
class Codec {
   public:
    void convert_params(string s, int &res) {
        res = 0;
        if (s.size() == 0) return;
        int beg = 0;
        int flag = 1;
        if (s[0] == '-') flag = -1, beg = 1;
        for (int i = beg; i < s.size(); i++) {
            res = res * 10 + s[i] - '0';
        }
        res *= flag;
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode *root) {
        if (root == NULL) {
            return "";
        }
        vector<string> res;
        res.push_back(to_string(root->val));
        queue<TreeNode *> Q;
        Q.push(root);
        while (!Q.empty()) {
            TreeNode *now = Q.front();
            Q.pop();
            if (now->left != NULL) {
                Q.push(now->left);
                res.push_back(to_string(now->left->val));
            } else {
                res.push_back("null");
            }
            if (now->right != NULL) {
                Q.push(now->right);
                res.push_back(to_string(now->right->val));
            } else {
                res.push_back("null");
            }
        }
        // Remove the last 0
        int idx = res.size() - 1;
        while (idx >= 0 && res[idx] == "null") idx--;
        res.resize(idx + 1);
        string ans = "";
        for (int i = 0; i < res.size(); i++) {
            ans += res[i];
            if (i != res.size() - 1) ans += ',';
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode *deserialize(string data) {
        if (data == "") return NULL;
        vector<string> v = split(data, ",");
        // Build a tree from bfs order
        int son_idx = 1;
        queue<TreeNode *> Q;
        TreeNode *th = new TreeNode(0);
        // The first element can't be null
        convert_params(v[0], th->val);
        th->left = th->right = NULL;
        Q.push(th);
        while (!Q.empty()) {
            TreeNode *now = Q.front();
            Q.pop();
            if (son_idx < v.size() && v[son_idx] != "null") {
                int left_son_val;
                convert_params(v[son_idx], left_son_val);
                TreeNode *tmp = new TreeNode(left_son_val);
                now->left = tmp;
                Q.push(tmp);
            }
            if (son_idx + 1 < v.size() && v[son_idx + 1] != "null") {
                int right_son_val;
                convert_params(v[son_idx + 1], right_son_val);
                TreeNode *tmp = new TreeNode(right_son_val);
                now->right = tmp;
                Q.push(tmp);
            }
            son_idx += 2;
        }
        return th;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));