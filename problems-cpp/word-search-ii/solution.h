/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

template <class T>
auto vect(const T &v, int n) { return vector<T>(n, v); }
template <class T, class... D>
auto vect(const T &v, int n, D... m) {
    return vector<decltype(vect(v, m...))>(n, vect(v, m...));
}

template <typename T>
static constexpr T inf = numeric_limits<T>::max() / 2;
mt19937_64 mrand(random_device{}());
long long rnd(long long x) { return mrand() % x; }
int lg2(long long x) { return sizeof(long long) * 8 - 1 - __builtin_clzll(x); }

typedef pair<int, string> pis;

struct TrieNode {
    vector<int> nxt;
    int finish = 0;
    TrieNode(int char_size) {
        nxt.resize(char_size, -1);
        finish = 0;
    }
    // 一些 hook 函数，用于 Trie 算法以及 ac 自动机, 可以覆盖这些函数来实现一些功能

    // 当加入到字典树后，对最终的节点(当前节点)进行一些操作
    void update_when_finish_in_trie() {
        finish++;
    };

    // 当加入到字典树时，根据当前节点和子节点的信息，对当前节点进行一些操作
    void update_when_push_in_trie(TrieNode &child_node) {
        finish++;
    };

    // 当构建 fail 函数时，根据当前节点和 fail 节点的信息，对当前节点进行一些操作
    void update_when_build_fail(TrieNode &fail_node){};
};

template <typename T = TrieNode>
struct Trie {
   public:
    vector<T> nodes;
    int root;

    int char_size;
    int margin;

    Trie(int char_size, int margin) : root(0), char_size(char_size), margin(margin) {
        nodes.push_back(T(char_size));
    }

    void add(const string &s, int s_idx, int node_idx) {
        /*
         * 将字符串 s 的 s_idx 位置开始的后缀加入到字典树中. node_idx 为当前节点的下标
         */
        if (s_idx == s.size()) {
            // 完成加入
            nodes[node_idx].update_when_finish_in_trie();
        } else {
            const int c = s[s_idx] - margin;
            if (nodes[node_idx].nxt[c] == -1) {
                nodes[node_idx].nxt[c] = nodes.size();
                nodes.push_back(T(char_size));
            }
            add(s, s_idx + 1, nodes[node_idx].nxt[c]);
            // 根据当前节点的子节点更新当前节点
            nodes[node_idx].update_when_push_in_trie(nodes[nodes[node_idx].nxt[c]]);
        }
    }

    void del(const string &s, int s_idx, int node_idx) {
        nodes[node_idx].finish -= 1;
        if (s_idx == s.size()) {
            return;
        } else {
            const int c = s[s_idx] - margin;
            del(s, s_idx + 1, nodes[node_idx].nxt[c]);
        }
    }

    int go(int node_idx, int c) {
        int res = nodes[node_idx].nxt[c];
        if (res == -1) return -1;
        if (nodes[res].finish == 0) return -1;
        return res;
    }

    void del(const string &s) {
        del(s, 0, root);
    }

    void add(const string &s) {
        add(s, 0, root);
    }
};

class Solution {
   public:
    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {
        int n = board.size();
        int m = board[0].size();

        Trie trie(26, 'a');
        set<string> S;
        for (int i = 0; i < words.size(); i++) {
            S.insert(words[i]);
            trie.add(words[i]);
        }
        debug(trie.nodes[trie.root].finish);
        set<string> ans;
        string now = "";
        int now_idx;

        auto vis = vect(false, n, m);
        int d[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
        function<void(int, int)> dfs = [&](int x, int y) {
            if (S.count(now)) {
                ans.insert(now);
                S.erase(now);
                trie.del(now);
            }
            if (S.size() == 0) return;
            for (int i = 0; i < 4; i++) {
                int x2 = x + d[i][0];
                int y2 = y + d[i][1];
                if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < m && vis[x2][y2] == 0) {
                    int go = trie.go(now_idx, board[x2][y2] - 'a');
                    if (go == -1) continue;
                    vis[x2][y2] = 1;
                    now += board[x2][y2];
                    int tmp = now_idx;
                    now_idx = go;
                    dfs(x2, y2);
                    vis[x2][y2] = 0;
                    now.pop_back();
                    now_idx = tmp;
                }
            }
        };
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                now = string(1, board[i][j]);
                now_idx = trie.root;
                now_idx = trie.go(now_idx, board[i][j] - 'a');
                if (now_idx == -1) continue;
                debug(i, j);
                vis[i][j] = 1;
                dfs(i, j);
                vis[i][j] = 0;
            }
        }
        vector<string> res;
        for (auto it : ans) {
            res.push_back(it);
        }
        return res;
    }
};