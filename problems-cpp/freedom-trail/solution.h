/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
class Solution {
   public:
    int findRotateSteps(string ring, string key) {
        int n = ring.size();
        int m = key.size();
        deque<pii> Q;
        const int inf = numeric_limits<int>::max() / 2;
        vector<vector<int>> dp(n, vector<int>(m + 1, inf));
        if (ring[0] == key[0]) {
            dp[0][1] = 0;
            Q.push_back({0, 1});
        } else {
            dp[0][0] = 0;
            Q.push_back({0, 0});
        }

        while (!Q.empty()) {
            auto [location, length] = Q.front();
            Q.pop_front();
            debug(location, length, dp[location][length]);
            if (length == m) continue;
            // + 0
            if (ring[location] == key[length]) {
                if (dp[location][length + 1] > dp[location][length]) {
                    dp[location][length + 1] = dp[location][length];
                    Q.push_front({location, length + 1});
                }
            }
            // + 1
            int new_go = (location + 1) % n;
            char it = ring[new_go];
            int new_length = length + (key[length] == it);
            if (dp[new_go][new_length] > dp[location][length] + 1) {
                dp[new_go][new_length] = dp[location][length] + 1;
                Q.push_back({new_go, new_length});
            }

            // -1
            new_go = (location + n - 1) % n;
            it = ring[new_go];
            new_length = length + (key[length] == it);
            if (dp[new_go][new_length] > dp[location][length] + 1) {
                dp[new_go][new_length] = dp[location][length] + 1;
                Q.push_back({new_go, new_length});
            }
        }
        int ans = inf;
        for (int i = 0; i < n; i++) {
            ans = min(ans, dp[i][m]);
        }
        debug(ans, m);
        return ans + m;
    }
};