/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;

class Solution {
   public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        pii start, end;
        int status = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1) {
                    start = {i, j};
                } else if (grid[i][j] == 2) {
                    end = {i, j};
                }
            }
        }

        vector<vector<int>> d, vis;
        d.resize(n * m, vector<int>(1 << (n * m)));
        vis.resize(n * m, vector<int>(1 << (n * m)));

        queue<pii> Q;

        auto get_idx = [&](int x, int y) {
            return x * m + y;
        };

        auto get_loc = [&](int idx) -> pii {
            return {idx / m, idx % m};
        };

        int start_idx = get_idx(start.first, start.second);

        Q.push({start_idx, 1 << start_idx});
        d[start_idx][1 << start_idx] = 1;
        int dir[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};

        while (!Q.empty()) {
            auto it = Q.front();
            Q.pop();
            pii location = get_loc(it.first);
            if (vis[it.first][it.second]) continue;
            vis[it.first][it.second] = 1;
            for (int i = 0; i < 4; i++) {
                int x2 = location.first + dir[i][0];
                int y2 = location.second + dir[i][1];
                if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < m && grid[x2][y2] != -1) {
                    int idx2 = get_idx(x2, y2);
                    if (((it.second >> idx2) & 1) == 0) {
                        d[idx2][it.second + (1 << idx2)] += d[it.first][it.second];
                        Q.push({idx2, it.second + (1 << idx2)});
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] != -1) {
                    status |= (1 << get_idx(i, j));
                }
            }
        }
        
        return d[get_idx(end.first, end.second)][status];
    }
};