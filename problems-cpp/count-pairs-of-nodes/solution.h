/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
class Solution {
   public:
    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {
        vector<int> sz(n + 1);
        int m = edges.size();
        map<pii, int> M;
        vector<vector<int>> V(n + 1);
        vector<int> SZ(n);
        for (int i = 0; i < m; i++) {
            int u = edges[i][0], v = edges[i][1];
            if (u > v) swap(u, v);
            sz[u]++;
            sz[v]++;
            if (M.count({u, v}) == 0) {
                V[u].push_back(v);
                V[v].push_back(u);
            }
            M[make_pair(u, v)]++;
        }

        for (int i = 0; i < n; i++) SZ[i] = sz[i + 1];
        sort(SZ.begin(), SZ.end());

        vector<int> f(n + 1);
        sort(f.begin() + 1, f.begin() + 1 + n, [&](int x, int y) {
            return sz[x] < sz[y];
        });

        vector<int> score;
        for (auto it : M) {
            int u = it.first.first, v = it.first.second;
            int times = it.second;
            score.push_back(sz[u] + sz[v] - times);
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < V[i].size(); j++) {
                V[i][j] = sz[V[i][j]];
            }
            sort(V[i].begin(), V[i].end());
        }
        sort(score.begin(), score.end());

        int q = queries.size();
        vector<int> ans(q);

        for (int i = 0; i < q; i++) {
            int limit = queries[i];

            // get result from linked pair
            int idx = upper_bound(score.begin(), score.end(), limit) - score.begin();
            ans[i] += score.size() - idx;
            debug(ans[i]);

            // get result from unlinked pair
            int res = 0;
            for (int j = 1; j <= n; j++) {
                int s1 = sz[j];
                if (s1 > limit) {
                    res += n - V[j].size() - 1;
                } else {
                    int need = limit - s1;
                    int idx = upper_bound(SZ.begin(), SZ.end(), need) - SZ.begin();
                    int have = n - idx;

                    int idx2 = upper_bound(V[j].begin(), V[j].end(), need) - V[j].begin();
                    int have2 = V[j].size() - idx2;

                    int tmp = have - have2;
                    if (s1 + s1 > limit) tmp--;
                    res += tmp;


                }
                debug(j, res);
            }
            res /= 2;
            ans[i] += res;
        }
        return ans;
    }
};