é¢˜ç›®æœ¬è´¨æ˜¯æ‰¾åˆ°åº¦æ•°å’Œæœ€å°çš„ä¸‰å…ƒç¯ï¼Œé—®é¢˜æ˜¯æ€ä¹ˆæšä¸¾å¤æ‚åº¦èƒ½æœ€ä¼˜ã€‚æœ€ç›´æ¥çš„æ€è·¯æ˜¯ä¸‰å±‚ for å¾ªç¯ã€‚ä½†æ˜¯è¿™æ ·åšå…¶å®å¤§é‡å¤šä½™çš„æšä¸¾ï¼Œè€Œæˆ‘ä»¬åªéœ€è¦æ‰¾æœ€å°çš„åº¦æ•°çš„ç‚¹ã€‚é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥å°†ç‚¹é¦–å…ˆæŒ‰ç…§åº¦æ•°æ’åºï¼Œç„¶ååœ¨ç¬¬ä¸€å±‚æšä¸¾çš„æ—¶å€™ï¼Œæšä¸¾æ‰€æœ‰çš„è¾¹(u, v)ï¼Œç¬¬äºŒå±‚æšä¸¾åªæŒ‰ç…§åº¦æ•°é¡ºåºæ‰¾åˆ°ç¬¬ä¸€ä¸ªç‚¹ w, æ»¡è¶³æ¡ä»¶(u, w) å’Œ (v, w) éƒ½æœ‰è¾¹å°±èƒ½ç›´æ¥ break äº†ã€‚

å¤æ‚åº¦å…¶å®æœ‰ç‚¹éš¾ç®—ï¼Œæƒ³æƒ³æœ€åæƒ…å†µï¼Œä¸¤å±‚ for å¾ªç¯éƒ½èµ°æ»¡äº†ã€‚è¿™ä¸ªå°±å˜æˆäº†å¦ä¸€ä¸ªé—®é¢˜ï¼Œå³ä¸€ä¸ªå›¾æ²¡æœ‰ä¸‰å…ƒç¯ï¼Œæœ€å¤šæœ‰å¤šå°‘æ¡è¾¹ã€‚è¿™é‡Œä»‹ç»ä¸€ä¸ª theoremã€‚

Mantel's theoremï¼š If a graph ğº on ğ‘› vertices contains no triangle then it contains at most \frac{n^2}{4} edges.

è¯æ˜é“¾æ¥ï¼šhttps://homes.cs.washington.edu/~anuprao/pubs/CSE421Wi2020/CyclesandTrees.pdf

å³æœ€å¤šä¼šæœ‰ \frac{n^2}{4} æ¡è¾¹ï¼Œé‚£ä¹ˆå¤æ‚åº¦å°±æ˜¯ O(\frac{n^3}{4})ã€‚

```cpp
/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
class Solution {
   public:
    int minTrioDegree(int n, vector<vector<int>>& edges) {
        int m = edges.size();
        vector<int> sz(n);
        vector<vector<bool>> mp(n, vector<bool>(n, 0));
        for (int i = 0; i < m; i++) {
            int u = edges[i][0] - 1, v = edges[i][1] - 1;
            sz[u]++;
            sz[v]++;
            mp[u][v] = mp[v][u] = 1;
        }

        vector<int> f(n);
        iota(f.begin(), f.end(), 0);
        sort(f.begin(), f.end(), [&](int x, int y) {
            return sz[x] < sz[y];
        });

        const int inf = 1e9;
        int ans = inf;
        for (int i = 0; i < m; i++) {
            int u = edges[i][0] - 1, v = edges[i][1] - 1;
            for (int j = 0; j < n; j++) {
                int idx = f[j];
                if (mp[idx][u] && mp[idx][v]) {
                    ans = min(ans, sz[u] + sz[v] + sz[idx] - 6);
                    break;
                }
            }
        }
        if (ans == inf) ans = -1;
        return ans;
    }
};
```