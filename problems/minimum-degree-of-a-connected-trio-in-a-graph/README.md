题目本质是找到度数和最小的三元环，问题是怎么枚举复杂度能最优。最直接的思路是三层 for 循环。但是这样做其实大量多余的枚举，而我们只需要找最小的度数的点。那么我们其实可以将点首先按照度数排序，然后在第一层枚举的时候，枚举所有的边(u, v)，第二层枚举只按照度数顺序找到第一个点 w, 满足条件(u, w) 和 (v, w) 都有边就能直接 break 了。

复杂度其实有点难算，想想最坏情况，两层 for 循环都走满了。这个就变成了另一个问题，即一个图没有三元环，最多有多少条边。这里介绍一个 theorem。

Mantel's theorem： If a graph 𝐺 on 𝑛 vertices contains no triangle then it contains at most \frac{n^2}{4} edges.

证明链接：https://homes.cs.washington.edu/~anuprao/pubs/CSE421Wi2020/CyclesandTrees.pdf

即最多会有 \frac{n^2}{4} 条边，那么复杂度就是 O(\frac{n^3}{4})。

```cpp
/*
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
*/
#if __has_include("../utils/cpp/help.hpp")
#include "../utils/cpp/help.hpp"
#elif __has_include("../../utils/cpp/help.hpp")
#include "../../utils/cpp/help.hpp"
#else
#define debug(...) 42
#endif

typedef pair<int, int> pii;
class Solution {
   public:
    int minTrioDegree(int n, vector<vector<int>>& edges) {
        int m = edges.size();
        vector<int> sz(n);
        vector<vector<bool>> mp(n, vector<bool>(n, 0));
        for (int i = 0; i < m; i++) {
            int u = edges[i][0] - 1, v = edges[i][1] - 1;
            sz[u]++;
            sz[v]++;
            mp[u][v] = mp[v][u] = 1;
        }

        vector<int> f(n);
        iota(f.begin(), f.end(), 0);
        sort(f.begin(), f.end(), [&](int x, int y) {
            return sz[x] < sz[y];
        });

        const int inf = 1e9;
        int ans = inf;
        for (int i = 0; i < m; i++) {
            int u = edges[i][0] - 1, v = edges[i][1] - 1;
            for (int j = 0; j < n; j++) {
                int idx = f[j];
                if (mp[idx][u] && mp[idx][v]) {
                    ans = min(ans, sz[u] + sz[v] + sz[idx] - 6);
                    break;
                }
            }
        }
        if (ans == inf) ans = -1;
        return ans;
    }
};
```