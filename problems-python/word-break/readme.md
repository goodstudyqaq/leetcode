# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
1. A question about one string can be solved by its sub-string. We can divide the string into two parts, and check if the first part is in the wordDict, and the second part can be divided into two parts, and so on.
2. Based on thought one, we can use recursion to solve this problem. And we can use memorization to reduce the time complexity.

# Complexity
- Time complexity: $O(n ^ 2)$. We need to check every sub-string of the string. And the time complexity of `startswith` is $O(n)$. So the time complexity is $O(n ^ 2)$. 

- Space complexity: $O(n ^ 2)$. We need to store the result of every sub-string. So the space complexity is $O(n ^ 2)$.

# Code
```
"""
Code generated by https://github.com/goodstudyqaq/leetcode-local-tester
"""
try:
    from utils.python3.help import *
except ImportError:
    pass # In leetcode environment, we don't need to import the help file.

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        @lru_cache(None)
        def dfs(s, wordDict):
            if not s:
                return True
            for word in wordDict:
                if s.startswith(word) and dfs(s[len(word):], wordDict):
                    return True
            return False
        
        return dfs(s, tuple(wordDict))



```